import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';
import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader';
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';
import TWEEN from 'three/examples/jsm/libs/tween.module.js';
import Stats from 'three/examples/jsm/libs/stats.module.js';

export default class ZThree {
  constructor(id) {
    this.id = id;
    this.el = document.getElementById(id);
    
    // åˆå§‹åŒ–é”®ç›˜æ§åˆ¶ç›¸å…³å˜é‡
    this.keys = {
      w: false,
      a: false,
      s: false,
      d: false
    };
    this.velocity = new THREE.Vector3();
    this.direction = new THREE.Vector3();
    this.moveSpeed = 0.05; // ç§»åŠ¨é€Ÿåº¦ï¼ˆå‡æ…¢ä¸€åŠï¼‰
    this.isMoving = false; // æ˜¯å¦æ­£åœ¨WASDç§»åŠ¨
    this.movementEndTimeout = null; // ç§»åŠ¨ç»“æŸå»¶è¿Ÿè®¡æ—¶å™¨
    this.initialTargetYOffset = null; // æ§åˆ¶å™¨ç›®æ ‡Yè½´åç§»é‡
  }

  // åˆå§‹åŒ–åœºæ™¯
  initThree() {
    let _this = this;
    let width = this.el.offsetWidth;
    let height = this.el.offsetHeight;
    this.scene = new THREE.Scene();
    this.textureLoader = new THREE.TextureLoader();
    this.camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    // è®¾ç½®æ‘„åƒå¤´åˆå§‹ä½ç½®ä¸º (0, 2.5, 0) - å›ºå®š2.5ç±³é«˜åº¦
    this.camera.position.set(0, 2.5, 0);
    this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true
    });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(width, height);
    
    // ä¿®å¤é€è§†é—®é¢˜çš„å…³é”®è®¾ç½®
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.renderer.outputEncoding = THREE.sRGBEncoding;
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1.0;
    
    // å¯ç”¨æ·±åº¦æµ‹è¯•å’Œæ·±åº¦å†™å…¥
    this.renderer.sortObjects = true;
    this.renderer.autoClear = true;
    this.renderer.autoClearColor = true;
    this.renderer.autoClearDepth = true;
    this.renderer.autoClearStencil = false;
    
    this.el.append(this.renderer.domElement);
    // this.renderer.setClearColor('#000');
    // this.gui = new GUI();

    // åˆå§‹åŒ–é”®ç›˜æ§åˆ¶
    this.initKeyboardControls();

    window.addEventListener(
      'resize',
      function() {
        _this.camera.aspect = _this.el.offsetWidth / _this.el.offsetHeight;
        _this.camera.updateProjectionMatrix();
        _this.renderer.setSize(_this.el.offsetWidth, _this.el.offsetHeight);
        if (_this.cssRenderer) {
          _this.cssRenderer.setSize(_this.el.offsetWidth, _this.el.offsetHeight);
        }
      },
      false
    );
  }

  // åˆå§‹åŒ–é”®ç›˜æ§åˆ¶
  initKeyboardControls() {
    const _this = this;
    
    // é”®ç›˜æŒ‰ä¸‹äº‹ä»¶
    document.addEventListener('keydown', (event) => {
      // é˜²æ­¢é‡å¤è§¦å‘
      if (event.repeat) return;
      
      switch (event.code) {
        case 'KeyW':
          _this.keys.w = true;
          _this.isMoving = true;
          break;
        case 'KeyA':
          _this.keys.a = true;
          _this.isMoving = true;
          break;
        case 'KeyS':
          _this.keys.s = true;
          _this.isMoving = true;
          break;
        case 'KeyD':
          _this.keys.d = true;
          _this.isMoving = true;
          break;
      }
    });

    // é”®ç›˜æ¾å¼€äº‹ä»¶
    document.addEventListener('keyup', (event) => {
      switch (event.code) {
        case 'KeyW':
          _this.keys.w = false;
          break;
        case 'KeyA':
          _this.keys.a = false;
          break;
        case 'KeyS':
          _this.keys.s = false;
          break;
        case 'KeyD':
          _this.keys.d = false;
          break;
      }
      
      // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æŒ‰é”®éƒ½æ¾å¼€äº†
      const hasAnyKey = _this.keys.w || _this.keys.a || _this.keys.s || _this.keys.d;
      if (!hasAnyKey) {
        // æ¸…é™¤ä¹‹å‰çš„è¶…æ—¶
        if (_this.movementEndTimeout) {
          clearTimeout(_this.movementEndTimeout);
        }
        
        // å»¶è¿Ÿ100msååœæ­¢ç§»åŠ¨çŠ¶æ€ï¼Œé¿å…è¯¯ç‚¹å‡»
        _this.movementEndTimeout = setTimeout(() => {
          _this.isMoving = false;
          // é‡æ–°å¯ç”¨OrbitControls
          if (_this.controls) {
            _this.controls.enabled = true;
            // ğŸ”¥ é‡æ–°å¯ç”¨æ§åˆ¶å™¨æ—¶æ›´æ–°ç›®æ ‡ç‚¹ï¼Œç¡®ä¿æ—‹è½¬å›´ç»•å½“å‰ä½ç½®
            if (_this.updateControlsTarget) {
              _this.updateControlsTarget();
            }
          }
        }, 100);
      }
    });
  }

  // æ›´æ–°æ‘„åƒå¤´ä½ç½®ï¼ˆWASDæ§åˆ¶ï¼‰
  updateCameraMovement() {
    // æ£€æŸ¥æ˜¯å¦æœ‰æŒ‰é”®æŒ‰ä¸‹ï¼Œæ²¡æœ‰æŒ‰é”®å°±ä¸æ›´æ–°
    const hasMovement = this.keys.w || this.keys.a || this.keys.s || this.keys.d;
    if (!hasMovement) {
      return;
    }

    // åªåœ¨å¼€å§‹ç§»åŠ¨æ—¶ç¦ç”¨OrbitControlsï¼Œé¿å…é¢‘ç¹åˆ‡æ¢
    if (this.isMoving && this.controls && this.controls.enabled) {
      this.controls.enabled = false;
    }

    // ä½¿ç”¨æ›´å¹³æ»‘çš„é˜»å°¼ç³»æ•°
    const damping = 0.8;
    this.velocity.multiplyScalar(damping);

    this.direction.z = Number(this.keys.w) - Number(this.keys.s);
    this.direction.x = Number(this.keys.d) - Number(this.keys.a);
    this.direction.normalize();

    if (this.keys.w || this.keys.s) this.velocity.z -= this.direction.z * this.moveSpeed;
    if (this.keys.a || this.keys.d) this.velocity.x -= this.direction.x * this.moveSpeed;

    // è·å–æ‘„åƒå¤´çš„æ–¹å‘å‘é‡ï¼Œä½†åªä½¿ç”¨æ°´å¹³æ–¹å‘ï¼ˆå¿½ç•¥Yè½´æ—‹è½¬ï¼‰
    const cameraDirection = new THREE.Vector3();
    this.camera.getWorldDirection(cameraDirection);
    // å°†Yåˆ†é‡è®¾ä¸º0ï¼Œåªä¿ç•™æ°´å¹³æ–¹å‘
    cameraDirection.y = 0;
    cameraDirection.normalize();
    
    // è®¡ç®—å³æ–¹å‘å‘é‡ï¼ˆä¹Ÿæ˜¯æ°´å¹³çš„ï¼‰
    const right = new THREE.Vector3();
    right.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0)).normalize();
    
    // ä¿å­˜å½“å‰çš„Yä½ç½®
    const fixedY = 2.5; // å°†Yä½ç½®å›ºå®šä¸º2.5ç±³
    
    // æ ¹æ®æ‘„åƒå¤´æœå‘è®¡ç®—ç§»åŠ¨å‘é‡ï¼ˆåªåœ¨æ°´å¹³é¢ç§»åŠ¨ï¼‰
    const moveVector = new THREE.Vector3();
    moveVector.addScaledVector(cameraDirection, -this.velocity.z);
    moveVector.addScaledVector(right, -this.velocity.x);
    
    // ç¢°æ’æ£€æµ‹ï¼šæ£€æŸ¥ç§»åŠ¨ç›®æ ‡ä½ç½®æ˜¯å¦ä¼šæ’å¢™
    const targetPosition = new THREE.Vector3(
      this.camera.position.x + moveVector.x,
      fixedY,
      this.camera.position.z + moveVector.z
    );
    
    // å¦‚æœæ²¡æœ‰ç¢°æ’ï¼Œæ‰æ‰§è¡Œç§»åŠ¨
    if (this.checkCollision(this.camera.position, targetPosition)) {
      // åªæ›´æ–°Xå’ŒZä½ç½®ï¼Œå¼ºåˆ¶ä¿æŒYä½ç½®ä¸º3ç±³
      this.camera.position.x += moveVector.x;
      this.camera.position.z += moveVector.z;
      this.camera.position.y = fixedY; // å¼ºåˆ¶é”å®šYä½ç½®ä¸º2.5ç±³

      // ğŸ”¥ ä½¿ç”¨åŠ¨æ€ç›®æ ‡ç³»ç»Ÿï¼Œç¡®ä¿ç§»åŠ¨åæ—‹è½¬ä¾ç„¶æ˜¯åŸåœ°æ—‹è½¬
      if (this.controls && this.updateControlsTarget) {
        this.updateControlsTarget();
      }
    }
  }

  // ç®€å•çš„ç¢°æ’æ£€æµ‹æ–¹æ³•
  checkCollision(currentPos, targetPos) {
    // å¦‚æœæ²¡æœ‰åœºæ™¯æˆ–æ¨¡å‹ï¼Œå…è®¸ç§»åŠ¨
    if (!this.scene || !this.rayModel) {
      console.log('æ²¡æœ‰åœºæ™¯æˆ–æ¨¡å‹æ•°æ®ï¼Œå…è®¸ç§»åŠ¨');
      return true;
    }

    // åˆ›å»ºå°„çº¿æ£€æµ‹å™¨
    if (!this.collisionRaycaster) {
      this.collisionRaycaster = new THREE.Raycaster();
    }

    // è®¡ç®—ç§»åŠ¨æ–¹å‘å’Œè·ç¦»
    const direction = new THREE.Vector3().subVectors(targetPos, currentPos);
    const moveDistance = direction.length();
    direction.normalize();
    
    // è·å–éœ€è¦æ£€æµ‹ç¢°æ’çš„ç‰©ä½“ï¼ˆå¢™ä½“ã€éšœç¢ç‰©ç­‰ï¼‰
    const collisionObjects = [];
    
    // éå†æ‰€æœ‰æ¨¡å‹å¯¹è±¡
    this.rayModel.forEach(obj => {
      const name = obj.name;
      if (name && (
        name.includes('å¢™') || 
        name.includes('wall') || 
        name.includes('Wall') ||
        name.includes('æ²™å‘') ||
        name.includes('ä¸­é—´å±') ||
        name === 'å¤©çª—æ …æ ' ||
        name === 'æˆ¿é¡¶' ||
        name === 'G-Object240'
      )) {
        collisionObjects.push(obj);
      }
    });

    // é¦–æ¬¡è¿è¡Œæ—¶è¾“å‡ºè°ƒè¯•ä¿¡æ¯
    if (!this.collisionObjectsLogged) {
      console.log('æ€»æ¨¡å‹æ•°é‡:', this.rayModel.length);
      console.log('å¯ç¢°æ’ç‰©ä½“æ•°é‡:', collisionObjects.length);
      console.log('å¯ç¢°æ’ç‰©ä½“åç§°:', collisionObjects.map(obj => obj.name));
      this.collisionObjectsLogged = true;
    }

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯ç¢°æ’ç‰©ä½“ï¼Œè¾“å‡ºè­¦å‘Š
    if (collisionObjects.length === 0) {
      console.warn('æ²¡æœ‰æ‰¾åˆ°å¯ç¢°æ’ç‰©ä½“ï¼Œè¯·æ£€æŸ¥æ¨¡å‹åç§°');
      return true; // æ²¡æœ‰ç¢°æ’ç‰©ä½“æ—¶å…è®¸ç§»åŠ¨
    }

    // å¢å¼ºç¢°æ’æ£€æµ‹ï¼šå¤šæ–¹å‘æ£€æµ‹
    const safetyDistance = 2.0; // å¢åŠ å®‰å…¨è·ç¦»ï¼Œé˜²æ­¢ç©¿æ¨¡ // ç»Ÿä¸€å®‰å…¨è·ç¦»ä¸º1.5å•ä½
    const checkDirections = [
      direction.clone(), // ä¸»è¦ç§»åŠ¨æ–¹å‘
      direction.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 6), // å³ä¾§30åº¦
      direction.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), -Math.PI / 6), // å·¦ä¾§30åº¦
    ];

    // æ£€æŸ¥å¤šä¸ªæ–¹å‘
    for (let i = 0; i < checkDirections.length; i++) {
      const checkDirection = checkDirections[i];
      
      // è®¾ç½®å°„çº¿èµ·ç‚¹å’Œæ–¹å‘
      this.collisionRaycaster.set(currentPos, checkDirection);
      
      // è¿›è¡Œå°„çº¿æ£€æµ‹
      const intersects = this.collisionRaycaster.intersectObjects(collisionObjects, true);
      
      // å¦‚æœæ£€æµ‹åˆ°ç¢°æ’
      if (intersects.length > 0) {
        const closestIntersect = intersects[0];
        const distance = closestIntersect.distance;
        
        // è¾“å‡ºå°„çº¿æ£€æµ‹è¯¦ç»†ä¿¡æ¯ï¼ˆå‡å°‘æ—¥å¿—é¢‘ç‡ï¼‰
        if (Math.random() < 0.1 && i === 0) { // åªåœ¨ä¸»æ–¹å‘å¶å°”è¾“å‡º
          console.log('å°„çº¿æ£€æµ‹ - èµ·ç‚¹:', currentPos, 'æ–¹å‘:', checkDirection, 'ç§»åŠ¨è·ç¦»:', moveDistance.toFixed(3));
          console.log('æ£€æµ‹åˆ°çš„ç¢°æ’æ•°é‡:', intersects.length);
          console.log('æœ€è¿‘ç¢°æ’ç‰©ä½“:', closestIntersect.object.name || 'æœªå‘½å');
          console.log('ç¢°æ’è·ç¦»:', distance.toFixed(3), 'å®‰å…¨è·ç¦»:', safetyDistance);
        }
        
        // å¦‚æœä»»ä½•æ–¹å‘æ£€æµ‹åˆ°è·ç¦»è¿‡è¿‘ï¼Œé˜»æ­¢ç§»åŠ¨
        if (distance < safetyDistance) {
          console.log('ğŸš« é˜»æ­¢ç§»åŠ¨ - æ–¹å‘', i === 0 ? 'å‰æ–¹' : i === 1 ? 'å³å‰æ–¹' : 'å·¦å‰æ–¹', 'è·ç¦»å¢™å£å¤ªè¿‘ï¼Œå½“å‰è·ç¦»:', distance.toFixed(2), 'æœ€å°å®‰å…¨è·ç¦»:', safetyDistance);
          return false; // é˜»æ­¢ç§»åŠ¨
        }
      }
    }

    // é¢å¤–æ£€æŸ¥ï¼šä»ç›®æ ‡ä½ç½®æ£€æµ‹å‘¨å›´æ˜¯å¦æœ‰å¢™ä½“
    const targetCheckDirections = [
      new THREE.Vector3(1, 0, 0),   // å³
      new THREE.Vector3(-1, 0, 0),  // å·¦
      new THREE.Vector3(0, 0, 1),   // å‰
      new THREE.Vector3(0, 0, -1),  // å
    ];

    for (let dir of targetCheckDirections) {
      this.collisionRaycaster.set(targetPos, dir);
      const intersects = this.collisionRaycaster.intersectObjects(collisionObjects, true);
      
      if (intersects.length > 0) {
        const distance = intersects[0].distance;
        if (distance < safetyDistance * 0.8) { // ç›®æ ‡ä½ç½®å‘¨å›´æ£€æŸ¥ç¨å¾®å®½æ¾ä¸€äº›
          console.log('ğŸš« é˜»æ­¢ç§»åŠ¨ - ç›®æ ‡ä½ç½®è·ç¦»å¢™å£å¤ªè¿‘:', distance.toFixed(2));
          return false;
        }
      }
    }

    if (Math.random() < 0.05) { // å¶å°”è¾“å‡ºå…è®¸ç§»åŠ¨çš„ä¿¡æ¯
      console.log('âœ… å…è®¸ç§»åŠ¨ - æ‰€æœ‰æ–¹å‘è·ç¦»å®‰å…¨');
    }
    
    return true; // å…è®¸ç§»åŠ¨
  }

  // å¯ç”¨/ç¦ç”¨WASDæ§åˆ¶
  enableWASDControl(enable = true) {
    this.wasdEnabled = enable;
  }

  // é‡æ–°å¯ç”¨OrbitControls
  enableOrbitControls() {
    if (this.controls) {
      this.controls.enabled = true;
    }
  }

  initLight() {
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    this.scene.add(ambientLight);
  }

  // åˆå§‹åŒ–helper
  initHelper() {
    this.axesHelper = new THREE.AxesHelper(100);
    this.scene.add(this.axesHelper);
  }

  // åˆ‡æ¢åæ ‡è½´æ˜¾ç¤ºçŠ¶æ€
  toggleAxesHelper(visible) {
    if (this.axesHelper) {
      if (visible === undefined) {
        this.axesHelper.visible = !this.axesHelper.visible;
      } else {
        this.axesHelper.visible = visible;
      }
    }
  }

  // åˆå§‹åŒ–æ§åˆ¶å™¨
  initOrbitControls() {
    let controls = new OrbitControls(this.camera, this.renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;
    controls.autoRotate = false;
    controls.autoRotateSpeed = 0.5;
    controls.enablePan = true;
    
    // æ·»åŠ è§¦æ‘¸è®¾å¤‡å…¼å®¹æ€§è®¾ç½®
    controls.touches = {
      ONE: THREE.TOUCH.ROTATE,
      TWO: THREE.TOUCH.DOLLY_PAN
    };
    
    // è®¾ç½®åˆç†çš„è¾¹ç•Œ
    controls.minDistance = 1.0; // å¢åŠ æœ€å°è·ç¦»ï¼Œé˜²æ­¢ç©¿æ¨¡
    controls.maxDistance = 50;
    controls.maxPolarAngle = Math.PI * 0.85; // é™åˆ¶å‚ç›´æ—‹è½¬è§’åº¦ï¼Œé˜²æ­¢ä»ä¸‹æ–¹çœ‹ç©¿æ¨¡å‹

    // ğŸ”¥ æ–°å¢ï¼šåŠ¨æ€ç›®æ ‡æ›´æ–°åŠŸèƒ½
    // è®©æ—‹è½¬ä¸­å¿ƒå§‹ç»ˆä¿æŒåœ¨ç›¸æœºå‰æ–¹ï¼Œå®ç°çœŸæ­£çš„åŸåœ°æ—‹è½¬
    this.updateControlsTarget = () => {
      // è·å–ç›¸æœºæœå‘
      const cameraDirection = new THREE.Vector3();
      this.camera.getWorldDirection(cameraDirection);
      
      // è®¾ç½®ç›®æ ‡ç‚¹åœ¨ç›¸æœºå‰æ–¹5ç±³å¤„
      const targetDistance = 5.0;
      const newTarget = this.camera.position.clone().add(
        cameraDirection.multiplyScalar(targetDistance)
      );
      
      controls.target.copy(newTarget);
    };

    let cameraStartPostion, cameraEndPostion;
    controls.addEventListener('start', () => {
      cameraStartPostion = this.camera.position.clone();
      controls.isClickLock = false;
      
      // ğŸ”¥ æ—‹è½¬å¼€å§‹æ—¶æ›´æ–°ç›®æ ‡ç‚¹ï¼Œç¡®ä¿å›´ç»•å½“å‰è§†çº¿æ–¹å‘æ—‹è½¬
      this.updateControlsTarget();
    });

    controls.addEventListener('end', () => {
      cameraEndPostion = this.camera.position;
      const startXYZ = Object.values(cameraStartPostion).reduce(function(prev, curr) {
        return prev + curr;
      });
      const endXYZ = Object.values(cameraEndPostion).reduce(function(prev, curr) {
        return prev + curr;
      });
      if (Math.abs(endXYZ - startXYZ) < 0.0001) {
        controls.isClickLock = false;
      } else {
        controls.isClickLock = true;
      }
      cameraStartPostion = null;
      cameraEndPostion = null;
    });
    
    this.controls = controls;
  }

  // åˆå§‹åŒ–status
  initStatus() {
    this.stats = new Stats();
    this.el.appendChild(this.stats.dom);
  }

  // åˆå§‹åŒ–å°„çº¿
  initRaycaster(callback, models = this.scene.children, eventName = 'click') {
    this.raycaster = new THREE.Raycaster();

    // ç»‘å®šç‚¹å‡»äº‹ä»¶
    this.el.addEventListener(eventName, (evt) => {
      // è·å–canvaså…ƒç´ çš„è¾¹ç•Œä¿¡æ¯
      const rect = this.renderer.domElement.getBoundingClientRect();
      
      // ä¿®æ­£é¼ æ ‡åæ ‡è®¡ç®—ï¼Œä½¿ç”¨canvasçš„ç›¸å¯¹ä½ç½®
      let mouse = {
        x: ((evt.clientX - rect.left) / rect.width) * 2 - 1,
        y: -((evt.clientY - rect.top) / rect.height) * 2 + 1
      };

      let activeObj = this.fireRaycaster(mouse, models);
      
      if (callback) {
        callback(activeObj, this, evt, mouse);
      }

      //é¼ æ ‡çš„å˜æ¢
      document.body.style.cursor = 'pointer';
    });
  }

  // è¿”å›é€‰ä¸­ç‰©ä½“
  fireRaycaster(pointer, models) {
    // ä½¿ç”¨ä¸€ä¸ªæ–°çš„åŸç‚¹å’Œæ–¹å‘æ¥æ›´æ–°å°„çº¿
    this.raycaster.setFromCamera(pointer, this.camera);

    let intersects = this.raycaster.intersectObjects(models, true);
    //
    if (intersects.length > 0) {
      let selectedObject = intersects[0];
      return selectedObject;
    } else {
      return false;
    }
  }

  loaderModel(option) {
    switch (option.type) {
      case 'obj':
        if (!this.objLoader) {
          this.objLoader = new OBJLoader();
        }
        if (!this.mtlLoader) {
          this.mtlLoader = new MTLLoader();
        }
        this.mtlLoader.load(option.mtlUrl || '', (materials) => {
          materials.preload();
          this.objLoader
            .setMaterials(materials)
            .load(option.url, option.onLoad, option.onProgress, option.onError);
        });
        break;

      case 'gltf':
      case 'glb':
        if (!this.gltfLoader) {
          this.gltfLoader = new GLTFLoader();
          let dracoLoader = new DRACOLoader();
          dracoLoader.setDecoderPath('draco/');
          this.gltfLoader.setDRACOLoader(dracoLoader);
        }
        this.gltfLoader.load(option.url, option.onLoad, option.onProgress, option.onError);
        break;

      case 'fbx':
        if (!this.fbxLoader) {
          this.fbxLoader = new FBXLoader();
        }
        this.fbxLoader.load(option.url, option.onLoad, option.onProgress, option.onError);
        break;

      case 'rgbe':
        if (!this.rgbeLoader) {
          this.rgbeLoader = new RGBELoader();
        }
        this.rgbeLoader.load(option.url, option.onLoad, option.onProgress, option.onError);
        break;

      case 'mp3':
      case 'wav':
        if (!this.audioaLoader) {
          this.audioaLoader = new THREE.AudioLoader();
        }
        this.audioaLoader.load(option.url, option.onLoad, option.onProgress, option.onError);
        break;

      default:
        console.error('å½“å‰åªæ”¯æŒobj, gltf, glb, fbx, rgbeæ ¼å¼');
        break;
    }
  }

  // è¿­ä»£åŠ è½½
  iterateLoad(objFileList, onProgress, onAllLoad) {
    let fileIndex = 0;
    let that = this;

    function iterateLoadForIt() {
      that.loaderModel({
        type: objFileList[fileIndex].type,
        dracoUrl: objFileList[fileIndex].dracoUrl,
        mtlUrl: objFileList[fileIndex].mtlUrl,
        url: objFileList[fileIndex].url,
        onLoad: function(object) {
          if (objFileList[fileIndex].onLoad) objFileList[fileIndex].onLoad(object);
          fileIndex++;
          if (fileIndex < objFileList.length) {
            iterateLoadForIt();
          } else {
            if (onAllLoad) onAllLoad();
          }
        },
        onProgress: function(xhr) {
          if (objFileList[fileIndex].onProgress) objFileList[fileIndex].onProgress(xhr, fileIndex);
          if (onProgress) onProgress(xhr, fileIndex);
        }
      });
    }
    iterateLoadForIt();
  }

  // åŠ è½½å¤©ç©ºç›’
  loaderSky(path) {
    let skyTexture = new THREE.CubeTextureLoader().setPath(path).load([
      'px.jpg', //å³
      'nx.jpg', //å·¦
      'py.jpg', //ä¸Š
      'ny.jpg', //ä¸‹
      'pz.jpg', //å‰
      'nz.jpg' //å
    ]);
    return skyTexture;
  }

  flyTo(option) {
    option.position = option.position || []; // ç›¸æœºæ–°çš„ä½ç½®
    option.controls = option.controls || []; // æ§åˆ¶å™¨æ–°çš„ä¸­å¿ƒç‚¹ä½ç½®(å›´ç»•æ­¤ç‚¹æ—‹è½¬ç­‰)
    option.duration = option.duration || 1000; // é£è¡Œæ—¶é—´
    option.easing = option.easing || TWEEN.Easing.Linear.None;
    TWEEN.removeAll();
    const curPosition = this.camera.position;
    const controlsTar = this.controls.target;
    
    // å¼ºåˆ¶è®¾ç½®Yåæ ‡ä¸º2.5ç±³
    const fixedY = 2.5;
    
          // å¦‚æœæä¾›äº†ä½ç½®ï¼Œç¡®ä¿Yåæ ‡ä¸º2.5ç±³
    if (option.position.length >= 2) {
      option.position[1] = fixedY;
    }
    
    const tween = new TWEEN.Tween({
      x1: curPosition.x, // ç›¸æœºå½“å‰ä½ç½®x
      y1: curPosition.y, // ç›¸æœºå½“å‰ä½ç½®y
      z1: curPosition.z, // ç›¸æœºå½“å‰ä½ç½®z
      x2: controlsTar.x, // æ§åˆ¶å½“å‰çš„ä¸­å¿ƒç‚¹x
      y2: controlsTar.y, // æ§åˆ¶å½“å‰çš„ä¸­å¿ƒç‚¹y
      z2: controlsTar.z // æ§åˆ¶å½“å‰çš„ä¸­å¿ƒç‚¹z
    })
      .to(
        {
          x1: option.position[0], // æ–°çš„ç›¸æœºä½ç½®x
          y1: fixedY, // æ–°çš„ç›¸æœºä½ç½®yå¼ºåˆ¶ä¸º2.5ç±³
          z1: option.position[2], // æ–°çš„ç›¸æœºä½ç½®z
          x2: option.controls[0], // æ–°çš„æ§åˆ¶ä¸­å¿ƒç‚¹ä½ç½®x
          y2: option.controls[1], // æ–°çš„æ§åˆ¶ä¸­å¿ƒç‚¹ä½ç½®x
          z2: option.controls[2] // æ–°çš„æ§åˆ¶ä¸­å¿ƒç‚¹ä½ç½®x
        },
        option.duration
      )
      .easing(TWEEN.Easing.Linear.None); // TWEEN.Easing.Cubic.InOut //åŒ€é€Ÿ
    tween.onUpdate(() => {
      this.controls.enabled = false;
      this.camera.position.set(tween._object.x1, fixedY, tween._object.z1);
      this.controls.target.set(tween._object.x2, tween._object.y2, tween._object.z2);
      this.controls.update();
      if (option.update instanceof Function) {
        option.update(tween);
      }
    });
    tween.onStart(() => {
      this.controls.enabled = false;
      if (option.start instanceof Function) {
        option.start();
      }
    });
    tween.onComplete(() => {
      this.controls.enabled = true;
      if (option.done instanceof Function) {
        option.done();
      }
    });
    tween.onStop(() => (option.stop instanceof Function ? option.stop() : ''));
    tween.start();
    TWEEN.add(tween);
    return tween;
  }

  // è®¡ç®—æ¨¡å‹çš„ä¸–ç•Œåæ ‡
  getModelWorldPostion(model) {
    let worldPosition = new THREE.Vector3();
    model.getWorldPosition(worldPosition);
    console.log(worldPosition);
    return worldPosition;
  }

  // æˆªå›¾åŠŸèƒ½
  takeScreenshot() {
    try {
      // ç¡®ä¿åœºæ™¯å·²ç»æ¸²æŸ“
      this.renderer.render(this.scene, this.camera);
      
      // è·å–canvasæ•°æ®URL
      const dataURL = this.renderer.domElement.toDataURL('image/png');
      
      // åˆ›å»ºä¸‹è½½é“¾æ¥
      const link = document.createElement('a');
      link.download = `gallery-screenshot-${new Date().getTime()}.png`;
      link.href = dataURL;
      
      // è§¦å‘ä¸‹è½½
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      console.log('ğŸ“¸ æˆªå›¾å·²ä¿å­˜');
      return true;
    } catch (error) {
      console.error('æˆªå›¾å¤±è´¥:', error);
      return false;
    }
  }

  // æ¸²æŸ“
  render(callback) {
    let _this = this;
    // æ¸²æŸ“
    function render() {
      // å¼ºåˆ¶é”å®šç›¸æœºé«˜åº¦ä¸º2.5ç±³
      if (_this.camera.position.y !== 2.5) {
        _this.camera.position.y = 2.5;
      }
      
      // æ›´æ–°WASDæ§åˆ¶
      if (_this.isMoving) {
        _this.updateCameraMovement();
      }

      // æ›´æ–°çŠ¶æ€
      if (_this.stats) {
        _this.stats.update();
      }

      requestAnimationFrame(render);

      TWEEN.update();

      if (callback) callback();
    }
    render();
  }
}
